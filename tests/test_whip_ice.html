<!DOCTYPE html>
<html>
<head>
    <title>WHIP ICE Debug</title>
</head>
<body>
    <h1>WHIP ICE Connection Debug</h1>
    <button id="startBtn">Start WHIP Connection</button>
    <button id="stopBtn" disabled>Stop Connection</button>
    <div id="status">Ready</div>
    <div id="logs"></div>

    <script>
        let peerConnection = null;
        let localStream = null;

        function log(message) {
            const logs = document.getElementById('logs');
            logs.innerHTML += '<div>' + new Date().toLocaleTimeString() + ': ' + message + '</div>';
            console.log(message);
        }

        async function startWhipConnection() {
            try {
                log('ðŸŽ¤ Requesting user media...');
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 48000
                    }
                });
                log('âœ… User media obtained: ' + localStream.getTracks().length + ' tracks');

                // Create peer connection with more ICE servers
                peerConnection = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' }
                    ],
                    iceCandidatePoolSize: 10
                });

                // Add local tracks
                log('ðŸŽµ Adding audio tracks to peer connection...');
                localStream.getTracks().forEach(track => {
                    log('ðŸŽµ Adding track: ' + track.kind + ' ' + track.id);
                    peerConnection.addTrack(track, localStream);
                });

                // Set up event handlers
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        log('ðŸ§Š ICE candidate: ' + event.candidate.candidate);
                    } else {
                        log('ðŸ§Š ICE candidate: null (gathering complete)');
                    }
                };

                peerConnection.oniceconnectionstatechange = () => {
                    log('ðŸ”— ICE connection state: ' + peerConnection.iceConnectionState);
                    if (peerConnection.iceConnectionState === 'connected') {
                        log('ðŸŽ‰ ICE connection established!');
                    } else if (peerConnection.iceConnectionState === 'failed') {
                        log('âŒ ICE connection failed!');
                    }
                };

                peerConnection.onconnectionstatechange = () => {
                    log('ðŸ”— Connection state: ' + peerConnection.connectionState);
                };

                peerConnection.onsignalingstatechange = () => {
                    log('ðŸ“¡ Signaling state: ' + peerConnection.signalingState);
                };

                peerConnection.ontrack = (event) => {
                    log('ðŸŽµ Received remote track: ' + event.track.kind);
                };

                // Create SDP offer
                log('ðŸ“ Creating SDP offer...');
                const offer = await peerConnection.createOffer();
                log('ðŸ“ SDP offer created, length: ' + offer.sdp.length);
                
                await peerConnection.setLocalDescription(offer);
                log('âœ… Local description set');

                // Wait for ICE gathering to complete
                log('â³ Waiting for ICE gathering...');
                await new Promise((resolve) => {
                    const checkGatheringState = () => {
                        log('ðŸ” ICE gathering state: ' + peerConnection.iceGatheringState);
                        if (peerConnection.iceGatheringState === 'complete') {
                            log('âœ… ICE gathering complete');
                            resolve();
                        } else {
                            setTimeout(checkGatheringState, 100);
                        }
                    };
                    checkGatheringState();
                });

                // Send WHIP request
                const whipUrl = 'http://localhost:8080/whip';
                log('ðŸ“¡ Sending WHIP request to: ' + whipUrl);
                log('ðŸ“„ SDP offer length: ' + offer.sdp.length);

                const response = await fetch(whipUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/sdp',
                    },
                    body: offer.sdp
                });

                log('ðŸ“¡ WHIP response status: ' + response.status);
                log('ðŸ“¡ WHIP response headers: ' + Object.fromEntries(response.headers.entries()));

                if (!response.ok) {
                    throw new Error('WHIP request failed: ' + response.status + ' ' + response.statusText);
                }

                const answerSdp = await response.text();
                log('ðŸ“„ SDP answer length: ' + answerSdp.length);
                log('ðŸ“„ SDP answer preview: ' + answerSdp.substring(0, 200) + '...');

                // Set remote description
                log('ðŸ”§ Setting remote description...');
                const answer = new RTCSessionDescription({ type: 'answer', sdp: answerSdp });
                await peerConnection.setRemoteDescription(answer);
                log('âœ… Remote description set successfully');

                log('ðŸŽ‰ WHIP connection established');
                log('ðŸ“Š Final connection state: ' + peerConnection.connectionState);
                log('ðŸ“Š Final ICE connection state: ' + peerConnection.iceConnectionState);
                log('ðŸ“Š Final signaling state: ' + peerConnection.signalingState);

                document.getElementById('status').textContent = 'Connected';
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;

                // Monitor connection state changes
                let lastConnectionState = peerConnection.connectionState;
                let lastIceState = peerConnection.iceConnectionState;
                
                setInterval(() => {
                    if (peerConnection) {
                        const currentConnectionState = peerConnection.connectionState;
                        const currentIceState = peerConnection.iceConnectionState;
                        
                        if (currentConnectionState !== lastConnectionState) {
                            log('ðŸ”„ Connection state changed: ' + lastConnectionState + ' â†’ ' + currentConnectionState);
                            lastConnectionState = currentConnectionState;
                        }
                        
                        if (currentIceState !== lastIceState) {
                            log('ðŸ”„ ICE state changed: ' + lastIceState + ' â†’ ' + currentIceState);
                            lastIceState = currentIceState;
                        }
                        
                        // Log current states every 10 seconds
                        if (Date.now() % 10000 < 1000) {
                            log('ðŸ“Š Current states - Connection: ' + currentConnectionState + ', ICE: ' + currentIceState + ', Signaling: ' + peerConnection.signalingState);
                        }
                    }
                }, 1000);

            } catch (error) {
                log('âŒ Error: ' + error.message);
                document.getElementById('status').textContent = 'Error: ' + error.message;
            }
        }

        function stopConnection() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            document.getElementById('status').textContent = 'Disconnected';
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            log('ðŸ”Œ Connection stopped');
        }

        document.getElementById('startBtn').onclick = startWhipConnection;
        document.getElementById('stopBtn').onclick = stopConnection;
    </script>
</body>
</html> 